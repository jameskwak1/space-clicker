<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ìš°ì£¼ ë°©ì¹˜í˜• í´ë¦¬ì»¤: ì¸í”¼ë‹ˆí‹° ì†Œë“œ (v4.4)</title>
  <style>
    /* ========== ê¸°ë³¸ ë¦¬ì…‹ ë° ìŠ¤íƒ€ì¼ ========== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%; overflow: hidden;
      font-family: 'Courier New', monospace;
      background: #050508; color: #00ffcc;
      -webkit-tap-highlight-color: transparent; touch-action: manipulation;
      user-select: none;
    }
    #gameContainer {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    @media (min-width: 769px) {
      #gameContainer { left: 50%; transform: translateX(-50%); width: 100%; max-width: 480px; height: 100vh; }
    }
    #gameCanvas {
      display: block; width: 100%; height: 100%;
      background: radial-gradient(ellipse at center, #1a0d1a 0%, #050510 70%, #000 100%);
      cursor: crosshair; image-rendering: pixelated;
    }
    
    /* UI ìŠ¤íƒ€ì¼ */
    #topUI, #bottomUI {
      position: fixed; left: 0; right: 0; z-index: 10; pointer-events: none;
    }
    #topUI { top: 0; padding: 10px 15px; background: linear-gradient(180deg, rgba(0,0,0,0.9), transparent); }
    
    #bottomUI { 
      bottom: 0; padding: 15px; 
      background: linear-gradient(0deg, rgba(0,0,0,0.95), rgba(0,0,0,0.8), transparent); 
      display: flex; flex-direction: column; gap: 10px;
      align-items: center;
    }
    
    @media (min-width: 769px) {
      #topUI, #bottomUI { left: 50%; transform: translateX(-50%); max-width: 480px; }
    }
    #topUI > *, #bottomUI > * { pointer-events: auto; }

    #statsRow { display: flex; justify-content: space-between; margin-bottom: 5px; width: 100%; align-items: center; }
    #goldDisplay, #stageDisplay { font-weight: bold; font-size: 16px; text-shadow: 0 0 5px currentColor; }
    #goldDisplay { color: #ffd700; }
    
    /* ë„ì „ ë²„íŠ¼ (ë³´ìŠ¤ì „ ì „ìš©) */
    #challengeBtn {
      display: none; /* ê¸°ë³¸ ìˆ¨ê¹€ */
      padding: 6px 12px;
      background: linear-gradient(135deg, #ff0000, #990000);
      color: #fff;
      border: 2px solid #ff5555;
      border-radius: 20px;
      font-weight: bold;
      font-size: 12px;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
      animation: pulse 1.5s infinite;
      cursor: pointer;
    }
    #challengeBtn.active { display: block; }
    
    @keyframes pulse {
      0% { transform: scale(1); box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
      50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(255, 0, 0, 0.8); }
      100% { transform: scale(1); box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); }
    }

    #healthBarContainer { width: 100%; height: 14px; background: #222; border: 1px solid #00ffcc; border-radius: 4px; position: relative; overflow: hidden; }
    #healthBarFill { height: 100%; width: 0%; background: linear-gradient(90deg, #ff4444, #ff8844); transition: width 0.1s; }
    #currentMonsterLabel { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 10px; color: #fff; text-shadow: 0 0 2px #000; }

    /* ë²„íŠ¼ ê·¸ë£¹ */
    #btnGroup { display: flex; gap: 10px; width: 100%; justify-content: center; }
    button { font-family: inherit; cursor: pointer; border-radius: 6px; border: 1px solid; }
    #shopBtn { flex: 1; padding: 10px; background: #0d2a2a; color: #00ffcc; border-color: #00ffcc; font-weight: bold; font-size: 14px; }
    #autoClickBtn { flex: 1; padding: 10px; background: #1a1a2a; color: #888; border-color: #555; font-size: 14px; }
    #autoClickBtn.on { background: #004444; color: #00ffcc; border-color: #00ffcc; }
    
    /* ìŠ¬ë¼ì´ë” */
    #sliderContainer {
      width: 100%; display: flex; align-items: center; gap: 10px;
      background: rgba(255, 255, 255, 0.05);
      padding: 8px 12px;
      border-radius: 8px;
      border: 1px solid #333;
    }
    #speedLabel { font-size: 14px; color: #00ffcc; font-weight: bold; white-space: nowrap; width: 80px; }
    input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
    input[type=range]:focus { outline: none; }
    input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; cursor: pointer; background: #333; border-radius: 3px; }
    input[type=range]::-webkit-slider-thumb { height: 18px; width: 18px; border-radius: 50%; background: #00ffcc; cursor: pointer; -webkit-appearance: none; margin-top: -6px; box-shadow: 0 0 10px #00ffcc; }

    /* ê°œë°œì ë²„íŠ¼ */
    #devAutoBtn {
      position: fixed; bottom: 120px; right: 20px; z-index: 100;
      padding: 8px 12px; background: #330000; color: #ff5555; 
      border: 1px solid #ff5555; font-size: 10px; font-weight: bold;
      opacity: 0.7; transition: opacity 0.2s;
    }
    #devAutoBtn.active { background: #ff0000; color: #fff; opacity: 1; box-shadow: 0 0 10px #ff0000; }
    @media (min-width: 769px) { #devAutoBtn { left: 50%; right: auto; transform: translateX(160px); } }

    /* ìƒì  ëª¨ë‹¬ */
    #shopModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100; align-items: center; justify-content: center; padding: 20px; }
    #shopModal.open { display: flex; }
    #shopContent { background: #0a1111; border: 2px solid #00ffcc; border-radius: 12px; padding: 20px; width: 100%; max-width: 400px; box-shadow: 0 0 30px rgba(0,255,204,0.2); }
    
    /* ìƒì  í—¤ë” ë° ë©€í‹°í”Œë¼ì´ì–´ ë²„íŠ¼ */
    .shopHeader { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .shopHeader h2 { color: #00ffcc; font-size: 20px; margin: 0; }
    
    #multiplierControls { display: flex; gap: 5px; }
    .mulBtn { 
      padding: 4px 8px; background: #1a1a2a; color: #666; border: 1px solid #444; border-radius: 4px; font-size: 11px; cursor: pointer; 
    }
    .mulBtn.active { background: #00ffcc; color: #000; border-color: #00ffcc; font-weight: bold; }

    .shopItem { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #222; }
    .shopItemInfo { flex: 1; margin-right: 10px; }
    .shopItemInfo .name { color: #fff; font-size: 14px; }
    .shopItemInfo .desc { color: #888; font-size: 11px; }
    .shopItemInfo .level { color: #ffd700; font-size: 11px; margin-top: 2px; }
    .shopItem button { background: #003300; border-color: #00ffcc; color: #00ffcc; padding: 8px 12px; font-size: 12px; min-width: 80px; text-align: center; }
    .shopItem button:disabled { opacity: 0.3; background: #222; border-color: #555; pointer-events: none; }
    .shopItem button:active { background: #005500; transform: scale(0.95); }
    #shopClose { width: 100%; margin-top: 15px; padding: 10px; background: #331111; border-color: #ff4444; color: #ff4444; }

    /* ì•Œë¦¼ ë©”ì‹œì§€ */
    #toastMsg {
      position: fixed; top: 20%; left: 50%; transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8); color: #fff; padding: 10px 20px;
      border-radius: 20px; border: 1px solid #fff;
      font-size: 14px; pointer-events: none; opacity: 0; transition: opacity 0.5s;
      z-index: 300; white-space: nowrap;
    }
    #toastMsg.show { opacity: 1; }
    #toastMsg.fail { border-color: #ff0000; color: #ffaaaa; }
    #toastMsg.success { border-color: #00ff00; color: #aaffaa; }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
  </div>

  <div id="topUI">
    <div id="statsRow">
      <span id="goldDisplay">ğŸ’° 0 G</span>
      <span id="stageDisplay">STAGE 1</span>
      <!-- ë„ì „ ë²„íŠ¼ -->
      <button id="challengeBtn">â˜ ï¸ ë³´ìŠ¤ ë ˆì´ë“œ</button>
    </div>
    <div id="healthBarContainer">
      <div id="healthBarFill"></div>
      <span id="currentMonsterLabel">ì ì„ ê³µê²©í•˜ì„¸ìš”!</span>
    </div>
  </div>

  <div id="bottomUI">
    <div id="btnGroup">
      <button id="shopBtn">ğŸ›’ ìƒì </button>
      <button id="autoClickBtn">âš¡ AUTO: OFF</button>
    </div>
    <div id="sliderContainer">
      <span id="speedLabel">ì†ë„: x1</span>
      <input type="range" id="speedSlider" min="1" max="20" value="1" step="1">
    </div>
  </div>

  <button id="devAutoBtn">ğŸ› ï¸ DEV</button>
  <div id="toastMsg"></div>

  <!-- ìƒì  ëª¨ë‹¬ -->
  <div id="shopModal">
    <div id="shopContent">
      <div class="shopHeader">
        <h2>ë¬´ê¸° ê°•í™”ì†Œ</h2>
        <div id="multiplierControls">
          <button class="mulBtn active" data-mul="1">x1</button>
          <button class="mulBtn" data-mul="10">x10</button>
          <button class="mulBtn" data-mul="100">x100</button>
          <button class="mulBtn" data-mul="MAX">MAX</button>
        </div>
      </div>

      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">âš”ï¸ ê²€ê¸° ê°•í™”</div>
          <div class="desc">ê³µê²©ë ¥ ëŒ€í­ ì¦ê°€</div>
          <div class="level" id="damageLevel">Lv.1</div>
        </div>
        <button id="buyDamage">1G</button>
      </div>
      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">ğŸ—¡ï¸ ì—°ì† ë² ê¸°</div>
          <div class="desc">í•œ ë²ˆì— ì—¬ëŸ¬ ë²ˆ íƒ€ê²©</div>
          <div class="level" id="countLevel">Lv.1</div>
        </div>
        <button id="buyCount">10G</button>
      </div>
      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">ğŸ¯ ì¹˜ëª…íƒ€ í™•ë¥ </div>
          <div class="desc">í™•ë¥  +1% (Max 100%)</div>
          <div class="level" id="critChanceLevel">Lv.1 (0%)</div>
        </div>
        <button id="buyCritChance">20G</button>
      </div>
      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">ğŸ’¥ ì¹˜ëª…íƒ€ í”¼í•´</div>
          <div class="desc">ë°ë¯¸ì§€ +10%</div>
          <div class="level" id="critDamageLevel">Lv.1 (150%)</div>
        </div>
        <button id="buyCritDamage">20G</button>
      </div>
      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">âš¡ ìë™ ì‚¬ëƒ¥</div>
          <div class="desc">ìë™ ê³µê²© ì†ë„ ì¦ê°€</div>
          <div class="level" id="autoSpeedLevel">Lv.1</div>
        </div>
        <button id="buyAutoSpeed">10G</button>
      </div>
      <button id="shopClose">ë‹«ê¸°</button>
    </div>
  </div>

  <script>
    // ============================================================
    // ê²Œì„ ì „ì—­ ì„¤ì •
    // ============================================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let canvasWidth = 0, canvasHeight = 0;
    let gameSpeed = 1;
    let gold = 0;
    let stage = 1;
    
    // ìƒíƒœ ê´€ë¦¬
    let isBossStage = false;  
    let isBossBattle = false; 
    
    // ì›¨ì´ë¸Œ ê´€ë¦¬
    const MAX_ENEMIES_PER_STAGE = 100; 
    let enemiesSpawnedInStage = 0;     
    let lastSpawnTime = 0;
    let lastSpawnedEnemyWidth = 30; 
    
    let enemies = [];
    let particles = [];
    let slashes = []; 
    
    let lastAutoFireTime = 0;   
    let lastDevFireTime = 0;    
    
    let autoClickEnabled = false;
    let devAutoEnabled = false;

    const PLAYER_WIDTH = 40;
    const PLAYER_HEIGHT = 30;
    let playerX = 0, playerY = 0;

    // ì—…ê·¸ë ˆì´ë“œ ìƒíƒœ
    let upgradeDamage = 1;
    let upgradeCount = 1;
    let upgradeAutoSpeed = 1;
    let upgradeCritChance = 1; 
    let upgradeCritDamage = 1; 
    
    // êµ¬ë§¤ ë°°ìœ¨ (1, 10, 100, 'MAX')
    let buyMultiplier = 1; 

    // ============================================================
    // ë¹„ìš© ê³„ì‚° í•¨ìˆ˜ (ë ˆë²¨ ê¸°ë°˜)
    // ============================================================
    const getCostDamage = (lv) => Math.floor(lv * 0.5) + 1; 
    const getCostCount = (lv) => 10 + Math.floor(Math.pow(lv, 1.8) * 5);
    const getCostAutoSpeed = (lv) => 10 + Math.floor(Math.pow(lv, 2.0));
    const getCostCritChance = (lv) => 20 + Math.floor(Math.pow(lv, 1.6) * 10);
    const getCostCritDamage = (lv) => 20 + Math.floor(Math.pow(lv, 1.6) * 10);

    const calculatePlayerDamage = (lv) => Math.floor(lv * 5 + Math.pow(lv, 1.6));
    const getCritChance = () => Math.min(100, upgradeCritChance - 1); 
    const getCritMultiplier = () => 1.5 + (upgradeCritDamage - 1) * 0.1; 

    function getAutoFireInterval() {
        const startInterval = 1000;
        const targetEarly = 300;
        const earlyLevels = 8;
        if (upgradeAutoSpeed <= earlyLevels) {
            const step = (startInterval - targetEarly) / (earlyLevels - 1);
            return Math.floor(startInterval - step * (upgradeAutoSpeed - 1));
        }
        const minInterval = 10;
        const decay = 0.98; 
        return Math.floor(Math.max(minInterval, targetEarly * Math.pow(decay, upgradeAutoSpeed - earlyLevels)));
    }

    // ============================================================
    // ëŒ€ëŸ‰ êµ¬ë§¤ ê³„ì‚° ë¡œì§
    // ============================================================
    // íŠ¹ì • ê°œìˆ˜(n)ë§Œí¼ ì‚´ ë•Œì˜ ì´ ë¹„ìš© ê³„ì‚°
    function calculateBulkCost(currentLv, costFunc, n) {
        let total = 0;
        for (let i = 0; i < n; i++) {
            total += costFunc(currentLv + i);
        }
        return total;
    }

    // MAX êµ¬ë§¤ ì‹œ: (ì‚´ ìˆ˜ ìˆëŠ” ê°œìˆ˜, ì´ ë¹„ìš©) ë°˜í™˜
    function calculateMaxBuy(currentLv, costFunc, currentGold, limitLv = Infinity) {
        let count = 0;
        let totalCost = 0;
        let lv = currentLv;
        
        while (true) {
            if (limitLv !== Infinity && lv >= limitLv) break; 
            
            let cost = costFunc(lv);
            if (currentGold >= totalCost + cost) {
                totalCost += cost;
                count++;
                lv++;
                // [íŒ¨ì¹˜ v4.4] MAX êµ¬ë§¤ ì œí•œ 1000 -> 100,000ìœ¼ë¡œ ìƒí–¥
                if (count >= 100000) break; 
            } else {
                break;
            }
        }
        return { count, totalCost };
    }

    // ============================================================
    // ë¦¬ì‚¬ì´ì¦ˆ
    // ============================================================
    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      canvasWidth = canvas.width = container.clientWidth;
      canvasHeight = canvas.height = container.clientHeight;
      playerX = canvasWidth/2 - PLAYER_WIDTH/2;
      playerY = canvasHeight - PLAYER_HEIGHT - 60; 
    }
    window.addEventListener('resize', () => { resizeCanvas(); initStars(); });
    resizeCanvas();

    // ============================================================
    // ì (Enemy) í´ë˜ìŠ¤
    // ============================================================
    class Enemy {
      constructor(type, health) {
        this.width = type === 'boss' ? 100 : type === 'miniboss' ? 60 : 30;
        this.height = type === 'boss' ? 80 : type === 'miniboss' ? 50 : 30;
        this.x = 0; this.y = 60; 
        this.type = type;
        this.maxHealth = health;
        this.health = health;
        this.baseSpeed = 3.0 + (stage * 0.1); 
        if(this.baseSpeed > 15) this.baseSpeed = 15; 
        this.direction = 1; 
        this.dropAmount = 30; 
      }
      update(dt) {
        const speed = this.baseSpeed * gameSpeed * (dt / 16);
        this.x += speed * this.direction;
        if (this.direction === 1 && this.x + this.width >= canvasWidth) {
            this.x = canvasWidth - this.width; this.y += this.dropAmount; this.direction = -1;
        } else if (this.direction === -1 && this.x <= 0) {
            this.x = 0; this.y += this.dropAmount; this.direction = 1;
        }
        if (this.y + this.height >= playerY) return true; 
        return false;
      }
      draw() {
        let color = '#00ffcc'; let glow = '#00ffcc';
        if (this.type === 'miniboss') { color = '#ffaa00'; glow='#ffaa00'; }
        if (this.type === 'boss') { color = '#ff0055'; glow='#ff0055'; }
        ctx.fillStyle = color; ctx.shadowColor = glow; ctx.shadowBlur = 10;
        ctx.fillRect(this.x, this.y, this.width, this.height); ctx.shadowBlur = 0;
        ctx.fillStyle = '#000';
        if (this.direction === 1) ctx.fillRect(this.x + this.width*0.6, this.y + this.height*0.2, this.width*0.15, this.width*0.15);
        else ctx.fillRect(this.x + this.width*0.2, this.y + this.height*0.2, this.width*0.15, this.width*0.15);
        const hpPercent = this.health / this.maxHealth;
        ctx.fillStyle = '#111'; ctx.fillRect(this.x, this.y - 6, this.width, 4);
        ctx.fillStyle = '#0f0'; ctx.fillRect(this.x, this.y - 6, this.width * hpPercent, 4);
      }
      takeDamage(dmg) {
        this.health -= dmg;
        if (this.health <= 0) {
          let reward = 1 + Math.floor(stage * 0.5);
          if (stage > 20) reward = Math.floor(reward * Math.pow(1.05, stage - 20));
          
          if (this.type === 'miniboss') reward *= 30; 
          // [íŒ¨ì¹˜] ë³´ìŠ¤ ë³´ìƒ ì¡°ì • (ìì£¼ ë‚˜ì˜¤ë‹ˆê¹Œ 200ë°° -> 100ë°°)
          if (this.type === 'boss') reward *= 100;    
          
          gold += reward;
          spawnParticles(this.x + this.width/2, this.y + this.height/2, this.type);
          return true; 
        }
        return false;
      }
    }

    // ============================================================
    // ìŠ¤í°, ì´í™íŠ¸, ê³µê²© ë¡œì§
    // ============================================================
    function trySpawnEnemy(now) {
        if (isBossBattle) {
            if (enemies.length === 0) spawnOneEnemy('boss');
            return;
        }
        if (isBossStage) {
            const currentSpeed = 3.0 + (stage * 0.1); 
            const gap = 15; 
            let safeInterval = (lastSpawnedEnemyWidth + gap) / currentSpeed * 20; 
            safeInterval = Math.max(60, safeInterval);
            if (now - lastSpawnTime > (safeInterval / gameSpeed)) {
                spawnOneEnemy('farming'); 
                lastSpawnTime = now;
            }
            return;
        }
        if (enemiesSpawnedInStage >= MAX_ENEMIES_PER_STAGE) return;
        const currentSpeed = 3.0 + (stage * 0.1); 
        const gap = 15; 
        let safeInterval = (lastSpawnedEnemyWidth + gap) / currentSpeed * 20; 
        safeInterval = Math.max(60, safeInterval); 
        if (now - lastSpawnTime > (safeInterval / gameSpeed)) {
            spawnOneEnemy('normal');
            lastSpawnTime = now;
        }
    }

    function spawnOneEnemy(mode) {
        let baseHealth = 10 + Math.pow(stage, 2.3);
        if (stage > 20) baseHealth *= Math.pow(1.08, stage - 20);
        let type = 'normal'; let health = baseHealth;
        
        if (mode === 'boss') { 
            type = 'boss'; 
            // [íŒ¨ì¹˜] ë³´ìŠ¤ ì²´ë ¥ ì¡°ì • (300ë°° -> 150ë°°)
            health = baseHealth * 150; 
        } 
        else if (mode === 'farming') { type = 'normal'; } 
        else {
            const currentCount = enemiesSpawnedInStage + 1;
            // 20ë°°ìˆ˜ ìŠ¤í…Œì´ì§€ëŠ” ë³´ìŠ¤ì¡´ì´ë¼ ì¼ë°˜ëª¹ ì¤‘ ì—˜ë¦¬íŠ¸ëŠ” ìŠ¤í‚µë¨ (ì´ë¯¸ ë³´ìŠ¤ê°€ ë§‰ê³  ìˆìœ¼ë‹ˆ)
            // ëŒ€ì‹  10ë°°ìˆ˜(10, 30, 50...) ìŠ¤í…Œì´ì§€ëŠ” ì—˜ë¦¬íŠ¸ ë“±ì¥
            if (currentCount === MAX_ENEMIES_PER_STAGE && stage % 10 === 0) { type = 'miniboss'; health = baseHealth * 50; }
        }
        const newEnemy = new Enemy(type, health);
        enemies.push(newEnemy);
        lastSpawnedEnemyWidth = newEnemy.width;
        if (mode === 'normal') enemiesSpawnedInStage++;
    }

    class SlashEffect {
        constructor(x, y, isCrit) {
            this.x = x; this.y = y; this.life = 1.0;
            this.angle = Math.random() * Math.PI * 2;
            this.isCrit = isCrit; this.scale = isCrit ? 1.5 : 1.0; 
        }
        update() { this.life -= this.isCrit ? 0.1 : 0.15; return this.life <= 0; }
        draw() {
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle); ctx.scale(this.scale, this.scale);
            ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI); 
            if (this.isCrit) { ctx.strokeStyle = `rgba(255, 50, 50, ${this.life})`; ctx.lineWidth = 6; ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10; } 
            else { ctx.strokeStyle = `rgba(200, 255, 255, ${this.life})`; ctx.lineWidth = 4; ctx.shadowBlur = 0; }
            ctx.stroke(); ctx.restore();
        }
    }

    function spawnParticles(x, y, type) {
      const color = type==='boss'?'#f05':(type==='miniboss'?'#fa0':'#0fc');
      for(let i=0; i<6; i++) {
        particles.push({ x, y, vx: (Math.random()-0.5)*8, vy: (Math.random()-0.5)*8, life: 1.0, color });
      }
    }

    function fire() {
        if(enemies.length === 0) return;
        let target = null; let maxY = -9999;
        enemies.forEach(e => { if (e.y > maxY) { maxY = e.y; target = e; } });
        if (target) {
            const isCrit = (Math.random() * 100) < getCritChance();
            slashes.push(new SlashEffect(target.x + target.width/2, target.y + target.height/2, isCrit));
            let finalDamage = calculatePlayerDamage(upgradeDamage);
            if (isCrit) finalDamage *= getCritMultiplier();
            for(let i=0; i<upgradeCount; i++) {
                if(target.health <= 0) break; 
                if(target.takeDamage(finalDamage)) {
                    const idx = enemies.indexOf(target); if(idx > -1) enemies.splice(idx, 1);
                    if (isBossBattle) { winStage(); return; }
                    if (enemies.length > 0) target = enemies[0]; else break;
                }
            }
        }
    }

    // ============================================================
    // ìŠ¤í…Œì´ì§€ ê´€ë¦¬ (íŒ¨ì¹˜: 20ìŠ¤í…Œì´ì§€ë§ˆë‹¤ ë³´ìŠ¤)
    // ============================================================
    function checkStageClear() {
        if (isBossStage || isBossBattle) return;
        if (enemiesSpawnedInStage >= MAX_ENEMIES_PER_STAGE && enemies.length === 0) { nextStage(); }
    }
    function nextStage() {
        stage++; enemiesSpawnedInStage = 0;
        // [íŒ¨ì¹˜] 20ìŠ¤í…Œì´ì§€ë§ˆë‹¤ ë³´ìŠ¤ì¡´
        if (stage % 20 === 0) {
            isBossStage = true; showToast(`STAGE ${stage} ë„ë‹¬! ë³´ìŠ¤ì—ê²Œ ë„ì „í•˜ì„¸ìš”!`, "success");
        } else {
            isBossStage = false;
            let stageReward = (1 + Math.floor(stage * 0.5)) * 10;
            if (stage > 20) stageReward = Math.floor(stageReward * Math.pow(1.05, stage - 20));
            gold += stageReward;
        }
        updateUI();
    }
    function winStage() {
        stage++; isBossBattle = false; isBossStage = false; enemies = []; enemiesSpawnedInStage = 0;
        showToast("BOSS CLEAR! í•œê³„ë¥¼ ëŒíŒŒí–ˆìŠµë‹ˆë‹¤!", "success");
        gold += calculatePlayerDamage(upgradeDamage) * 100; 
        updateUI();
    }
    function failStage() {
        if (isBossBattle) { isBossBattle = false; enemies = []; showToast("ë³´ìŠ¤ì „ íŒ¨ë°°! ë‹¤ì‹œ ì¤€ë¹„í•˜ì„¸ìš”.", "fail"); } 
        else { enemies = []; enemiesSpawnedInStage = 0; showToast("ë°©ì–´ì„  ë¶•ê´´! ì¬ì •ë¹„í•©ë‹ˆë‹¤.", "fail"); }
    }
    function showToast(msg, type) {
        const toast = document.getElementById('toastMsg'); toast.textContent = msg;
        toast.className = type === 'fail' ? 'fail show' : 'success show';
        setTimeout(() => { toast.classList.remove('show'); }, 2000);
    }

    // ============================================================
    // ë©”ì¸ ë£¨í”„
    // ============================================================
    let lastTime = 0;
    function gameLoop(now) {
      const dt = Math.min(now - lastTime, 100);
      lastTime = now;
      trySpawnEnemy(now);
      checkStageClear();
      if (autoClickEnabled) { let interval = getAutoFireInterval() / gameSpeed; if (now - lastAutoFireTime > interval) { fire(); lastAutoFireTime = now; } }
      if (devAutoEnabled) { let devInterval = 10 / gameSpeed; if (now - lastDevFireTime > devInterval) { fire(); lastDevFireTime = now; } }
      ctx.fillStyle = '#050508'; ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      drawStars();
      for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i]; const hitPlayer = e.update(dt); e.draw();
          if (hitPlayer) { failStage(); break; }
      }
      for(let i=particles.length-1; i>=0; i--) {
          let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.05;
          ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 4, 4);
          if(p.life <= 0) particles.splice(i,1);
      }
      ctx.globalAlpha = 1.0;
      for(let i=slashes.length-1; i>=0; i--) { slashes[i].draw(); if(slashes[i].update()) slashes.splice(i, 1); }
      drawPlayer(now);
      updateUI(); // UI ì—…ë°ì´íŠ¸
      requestAnimationFrame(gameLoop);
    }

    function drawPlayer(now) {
        const cx = playerX + PLAYER_WIDTH/2; const cy = playerY + PLAYER_HEIGHT/2;
        ctx.fillStyle = '#00ffcc'; ctx.shadowColor = '#00ffcc'; ctx.shadowBlur = 15;
        ctx.beginPath(); ctx.moveTo(cx, playerY); ctx.lineTo(playerX + PLAYER_WIDTH, playerY + PLAYER_HEIGHT); 
        ctx.lineTo(cx, playerY + PLAYER_HEIGHT - 10); ctx.lineTo(playerX, playerY + PLAYER_HEIGHT); 
        ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0;
    }

    // ============================================================
    // UI ì—…ë°ì´íŠ¸ & êµ¬ë§¤ ë¡œì§ í†µí•©
    // ============================================================
    function updateShopButton(btnId, currentLv, costFunc, limitLv = Infinity) {
        const btn = document.getElementById(btnId);
        let costText = "";
        let affordable = false;
        let buyAmount = 0;
        let totalCost = 0;

        if (buyMultiplier === 'MAX') {
            const result = calculateMaxBuy(currentLv, costFunc, gold, limitLv);
            buyAmount = result.count;
            totalCost = result.totalCost;
            if (buyAmount > 0) {
                costText = `+${buyAmount} (${totalCost.toLocaleString()}G)`;
                affordable = true;
            } else {
                costText = `${costFunc(currentLv).toLocaleString()}G (MAX)`;
                affordable = false;
            }
        } 
        else {
            buyAmount = buyMultiplier;
            if (currentLv + buyAmount > limitLv) {
                buyAmount = limitLv - currentLv;
            }
            if (buyAmount <= 0) {
                costText = "MAX";
                affordable = false;
            } else {
                totalCost = calculateBulkCost(currentLv, costFunc, buyAmount);
                costText = `${totalCost.toLocaleString()}G`;
                affordable = (gold >= totalCost);
            }
        }

        btn.textContent = costText;
        btn.disabled = !affordable;
        return { affordable, totalCost, buyAmount };
    }

    function updateUI() {
        document.getElementById('goldDisplay').textContent = `ğŸ’° ${Math.floor(gold).toLocaleString()} G`;
        
        let stageText = `STAGE ${stage}`;
        // [íŒ¨ì¹˜] 20ìŠ¤í…Œì´ì§€ë§ˆë‹¤ ë³´ìŠ¤ì¡´ í‘œì‹œ
        if (stage % 20 === 0) stageText += " [BOSS ZONE]";
        let status = isBossBattle ? "âš”ï¸ ë³´ìŠ¤ êµì „ ì¤‘!" : (isBossStage ? "ğŸ›‘ ë³´ìŠ¤ ëŒ€ê¸° (íŒŒë° ì¤‘)" : "ì§„ê²© ì¤‘...");
        
        const remaining = isBossStage ? 0 : MAX_ENEMIES_PER_STAGE - enemiesSpawnedInStage;
        document.getElementById('stageDisplay').textContent = isBossStage ? stageText : `${stageText} (ë‚¨ì€ ì : ${remaining})`;
        document.getElementById('currentMonsterLabel').textContent = status;

        const btn = document.getElementById('challengeBtn');
        if (isBossStage && !isBossBattle) { btn.classList.add('active'); btn.textContent = "â˜ ï¸ ë³´ìŠ¤ ë ˆì´ë“œ ì‹œì‘"; } 
        else { btn.classList.remove('active'); }

        document.querySelector('#damageLevel').textContent = `Lv.${upgradeDamage} (DMG: ${calculatePlayerDamage(upgradeDamage).toLocaleString()})`;
        document.querySelector('#countLevel').textContent = `Lv.${upgradeCount}`;
        const currentInterval = getAutoFireInterval();
        document.querySelector('#autoSpeedLevel').textContent = `Lv.${upgradeAutoSpeed} (${(currentInterval/1000).toFixed(3)}s)`;
        
        const critChance = getCritChance();
        document.querySelector('#critChanceLevel').textContent = `Lv.${upgradeCritChance} (${critChance}%)`;
        document.querySelector('#critDamageLevel').textContent = `Lv.${upgradeCritDamage} (${Math.floor(getCritMultiplier()*100)}%)`;

        updateShopButton('buyDamage', upgradeDamage, getCostDamage);
        updateShopButton('buyCount', upgradeCount, getCostCount);
        updateShopButton('buyAutoSpeed', upgradeAutoSpeed, getCostAutoSpeed);
        updateShopButton('buyCritChance', upgradeCritChance, getCostCritChance, 101); 
        updateShopButton('buyCritDamage', upgradeCritDamage, getCostCritDamage);

        let target = enemies[0];
        const bar = document.getElementById('healthBarFill');
        if (target) { bar.style.width = `${(target.health / target.maxHealth) * 100}%`; } else { bar.style.width = '0%'; }
    }

    const stars = [];
    function initStars() {
        stars.length = 0;
        for(let i=0; i<60; i++) stars.push({x:Math.random()*canvasWidth, y:Math.random()*canvasHeight, s:Math.random()*2});
    }
    function drawStars() { ctx.fillStyle = '#fff'; stars.forEach(s => { ctx.fillRect(s.x, s.y, s.s, s.s); }); }

    canvas.addEventListener('click', fire); 

    const modal = document.getElementById('shopModal');
    document.getElementById('shopBtn').onclick = () => modal.classList.add('open');
    document.getElementById('shopClose').onclick = () => modal.classList.remove('open');
    document.getElementById('challengeBtn').onclick = () => { isBossBattle = true; enemies = []; showToast("ë³´ìŠ¤ ë“±ì¥! ì „íˆ¬ ê°œì‹œ!", "success"); };

    const devBtn = document.getElementById('devAutoBtn');
    devBtn.onclick = () => {
        devAutoEnabled = !devAutoEnabled; devBtn.classList.toggle('active', devAutoEnabled);
        if(devAutoEnabled) { devBtn.textContent = "ğŸ› ï¸ DEV: ON"; lastDevFireTime = performance.now(); } 
        else { devBtn.textContent = "ğŸ› ï¸ DEV: OFF"; }
    };

    const speedSlider = document.getElementById('speedSlider');
    const speedLabel = document.getElementById('speedLabel');
    speedSlider.addEventListener('input', (e) => { gameSpeed = parseInt(e.target.value); speedLabel.textContent = `ì†ë„: x${gameSpeed}`; });

    document.querySelectorAll('.mulBtn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.mulBtn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            const val = btn.dataset.mul;
            buyMultiplier = val === 'MAX' ? 'MAX' : parseInt(val);
            updateUI(); 
        });
    });

    function processBuy(type) {
        let currentLv, costFunc, limitLv = Infinity;
        if (type === 'damage') { currentLv = upgradeDamage; costFunc = getCostDamage; }
        else if (type === 'count') { currentLv = upgradeCount; costFunc = getCostCount; }
        else if (type === 'auto') { currentLv = upgradeAutoSpeed; costFunc = getCostAutoSpeed; }
        else if (type === 'critChance') { currentLv = upgradeCritChance; costFunc = getCostCritChance; limitLv = 101; }
        else if (type === 'critDamage') { currentLv = upgradeCritDamage; costFunc = getCostCritDamage; }

        let count = 0, cost = 0;
        if (buyMultiplier === 'MAX') {
            const res = calculateMaxBuy(currentLv, costFunc, gold, limitLv);
            count = res.count; cost = res.totalCost;
        } else {
            count = buyMultiplier;
            if (currentLv + count > limitLv) count = limitLv - currentLv;
            if (count > 0) {
                cost = calculateBulkCost(currentLv, costFunc, count);
                if (gold < cost) count = 0; 
            }
        }

        if (count > 0) {
            gold -= cost;
            if (type === 'damage') upgradeDamage += count;
            else if (type === 'count') upgradeCount += count;
            else if (type === 'auto') upgradeAutoSpeed += count;
            else if (type === 'critChance') upgradeCritChance += count;
            else if (type === 'critDamage') upgradeCritDamage += count;
            updateUI();
        }
    }

    document.getElementById('buyDamage').onclick = () => processBuy('damage');
    document.getElementById('buyCount').onclick = () => processBuy('count');
    document.getElementById('buyAutoSpeed').onclick = () => processBuy('auto');
    document.getElementById('buyCritChance').onclick = () => processBuy('critChance');
    document.getElementById('buyCritDamage').onclick = () => processBuy('critDamage');

    const autoBtn = document.getElementById('autoClickBtn');
    autoBtn.onclick = () => {
        autoClickEnabled = !autoClickEnabled; autoBtn.classList.toggle('on', autoClickEnabled);
        autoBtn.textContent = autoClickEnabled ? "âš¡ AUTO: ON" : "âš¡ AUTO: OFF";
    };

    initStars();
    requestAnimationFrame(gameLoop);

  </script>
</body>
</html>
