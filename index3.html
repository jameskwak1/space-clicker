<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ìš°ì£¼ ë°©ì¹˜í˜• í´ë¦¬ì»¤: ì¸í”¼ë‹ˆí‹° ì†Œë“œ (Crit Ver.)</title>
  <style>
    /* ========== ê¸°ë³¸ ë¦¬ì…‹ ë° ìŠ¤íƒ€ì¼ ========== */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%; overflow: hidden;
      font-family: 'Courier New', monospace;
      background: #050508; color: #00ffcc;
      -webkit-tap-highlight-color: transparent; touch-action: manipulation;
      user-select: none;
    }
    #gameContainer {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    @media (min-width: 769px) {
      #gameContainer { left: 50%; transform: translateX(-50%); width: 100%; max-width: 480px; height: 100vh; }
    }
    #gameCanvas {
      display: block; width: 100%; height: 100%;
      background: radial-gradient(ellipse at center, #1a0d1a 0%, #050510 70%, #000 100%);
      cursor: crosshair; image-rendering: pixelated;
    }
    
    /* UI ìŠ¤íƒ€ì¼ */
    #topUI, #bottomUI {
      position: fixed; left: 0; right: 0; z-index: 10; pointer-events: none;
    }
    #topUI { top: 0; padding: 10px 15px; background: linear-gradient(180deg, rgba(0,0,0,0.9), transparent); }
    #bottomUI { bottom: 0; padding: 12px 15px; background: linear-gradient(0deg, rgba(0,0,0,0.9), transparent); display: flex; justify-content: space-between; align-items: center; }
    
    @media (min-width: 769px) {
      #topUI, #bottomUI { left: 50%; transform: translateX(-50%); max-width: 480px; }
    }
    #topUI > *, #bottomUI > * { pointer-events: auto; }

    #statsRow { display: flex; justify-content: space-between; margin-bottom: 5px; width: 100%; }
    #goldDisplay, #stageDisplay { font-weight: bold; font-size: 16px; text-shadow: 0 0 5px currentColor; }
    #goldDisplay { color: #ffd700; }
    
    #healthBarContainer { width: 100%; height: 14px; background: #222; border: 1px solid #00ffcc; border-radius: 4px; position: relative; overflow: hidden; }
    #healthBarFill { height: 100%; width: 0%; background: linear-gradient(90deg, #ff4444, #ff8844); transition: width 0.1s; }
    #currentMonsterLabel { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 10px; color: #fff; text-shadow: 0 0 2px #000; }

    /* ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    button { font-family: inherit; cursor: pointer; border-radius: 6px; border: 1px solid; }
    #shopBtn { padding: 8px 16px; background: #0d2a2a; color: #00ffcc; border-color: #00ffcc; font-weight: bold; }
    #autoClickBtn { padding: 8px 12px; background: #1a1a2a; color: #888; border-color: #555; font-size: 12px; }
    #autoClickBtn.on { background: #004444; color: #00ffcc; border-color: #00ffcc; }
    
    #speedControls { display: flex; gap: 4px; }
    .speedBtn { padding: 6px 10px; background: #1a1a2a; color: #666; border-color: #444; font-size: 12px; }
    .speedBtn.active { background: #00ffcc; color: #000; font-weight: bold; }

    /* ê°œë°œì ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    #devAutoBtn {
      position: fixed; bottom: 80px; right: 20px; z-index: 100;
      padding: 8px 12px; background: #330000; color: #ff5555; 
      border: 1px solid #ff5555; font-size: 10px; font-weight: bold;
      opacity: 0.7; transition: opacity 0.2s;
    }
    #devAutoBtn.active { background: #ff0000; color: #fff; opacity: 1; box-shadow: 0 0 10px #ff0000; }
    @media (min-width: 769px) {
      #devAutoBtn { left: 50%; right: auto; transform: translateX(160px); }
    }

    /* ìƒì  ëª¨ë‹¬ */
    #shopModal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100; align-items: center; justify-content: center; padding: 20px; }
    #shopModal.open { display: flex; }
    #shopContent { background: #0a1111; border: 2px solid #00ffcc; border-radius: 12px; padding: 20px; width: 100%; max-width: 360px; box-shadow: 0 0 30px rgba(0,255,204,0.2); }
    #shopContent h2 { text-align: center; color: #00ffcc; margin-bottom: 15px; }
    .shopItem { display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid #222; }
    .shopItemInfo { flex: 1; margin-right: 10px; }
    .shopItemInfo .name { color: #fff; font-size: 14px; }
    .shopItemInfo .desc { color: #888; font-size: 11px; }
    .shopItemInfo .level { color: #ffd700; font-size: 11px; margin-top: 2px; }
    .shopItem button { background: #003300; border-color: #00ffcc; color: #00ffcc; padding: 6px 12px; font-size: 11px; width: 75px; user-select: none; }
    .shopItem button:disabled { opacity: 0.3; background: #222; border-color: #555; pointer-events: none; }
    .shopItem button:active { background: #005500; transform: scale(0.95); }
    #shopClose { width: 100%; margin-top: 15px; padding: 10px; background: #331111; border-color: #ff4444; color: #ff4444; }

    /* ê²Œì„ì˜¤ë²„ */
    #gameOverOverlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 200; flex-direction: column; align-items: center; justify-content: center; }
    #gameOverOverlay.show { display: flex; }
    #gameOverOverlay h2 { color: #ff4444; font-size: 32px; margin-bottom: 10px; }
    #restartBtn { padding: 12px 30px; background: #00ffcc; color: #000; border: none; font-weight: bold; margin-top: 20px; }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
  </div>

  <div id="topUI">
    <div id="statsRow">
      <span id="goldDisplay">ğŸ’° 0 G</span>
      <span id="stageDisplay">STAGE 1</span>
    </div>
    <div id="healthBarContainer">
      <div id="healthBarFill"></div>
      <span id="currentMonsterLabel">ì ì„ ê³µê²©í•˜ì„¸ìš”!</span>
    </div>
  </div>

  <div id="bottomUI">
    <button id="shopBtn">ğŸ›’ ìƒì </button>
    <button id="autoClickBtn">âš¡ AUTO: OFF</button>
    <div id="speedControls">
      <button class="speedBtn active" data-speed="1">x1</button>
      <button class="speedBtn" data-speed="2">x2</button>
      <button class="speedBtn" data-speed="4">x4</button>
    </div>
  </div>

  <!-- ê°œë°œì ë²„íŠ¼ -->
  <button id="devAutoBtn">ğŸ› ï¸ DEV</button>

  <div id="shopModal">
    <div id="shopContent">
      <h2>ë¬´ê¸° ê°•í™”ì†Œ</h2>
      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">âš”ï¸ ê²€ê¸° ê°•í™”</div>
          <div class="desc">ê³µê²©ë ¥ ì¦ê°€</div>
          <div class="level" id="damageLevel">Lv.1</div>
        </div>
        <button id="buyDamage">1G</button>
      </div>
      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">ğŸ—¡ï¸ ì—°ì† ë² ê¸°</div>
          <div class="desc">í•œ ë²ˆì— ì—¬ëŸ¬ ë²ˆ íƒ€ê²©</div>
          <div class="level" id="countLevel">Lv.1</div>
        </div>
        <button id="buyCount">10G</button>
      </div>
      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">ğŸ¯ ì¹˜ëª…íƒ€ í™•ë¥ </div>
          <div class="desc">í™•ë¥  +1%</div>
          <div class="level" id="critChanceLevel">Lv.1 (0%)</div>
        </div>
        <button id="buyCritChance">20G</button>
      </div>
      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">ğŸ’¥ ì¹˜ëª…íƒ€ í”¼í•´</div>
          <div class="desc">ë°ë¯¸ì§€ +10%</div>
          <div class="level" id="critDamageLevel">Lv.1 (150%)</div>
        </div>
        <button id="buyCritDamage">20G</button>
      </div>
      <div class="shopItem">
        <div class="shopItemInfo">
          <div class="name">âš¡ ìë™ ì‚¬ëƒ¥</div>
          <div class="desc">ìë™ ê³µê²© ì†ë„ ì¦ê°€</div>
          <div class="level" id="autoSpeedLevel">Lv.1</div>
        </div>
        <button id="buyAutoSpeed">10G</button>
      </div>
      <button id="shopClose">ë‹«ê¸°</button>
    </div>
  </div>

  <div id="gameOverOverlay">
    <h2>GAME OVER</h2>
    <p>ëª¬ìŠ¤í„°ì—ê²Œ ë‹¹í–ˆìŠµë‹ˆë‹¤!</p>
    <button id="restartBtn">ë‹¤ì‹œ ì‹œì‘</button>
  </div>

  <script>
    // ============================================================
    // ê²Œì„ ì „ì—­ ì„¤ì •
    // ============================================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let canvasWidth = 0, canvasHeight = 0;
    let gameSpeed = 1;
    let gold = 0;
    let stage = 1;
    
    // ì›¨ì´ë¸Œ ê´€ë¦¬
    const MAX_ENEMIES_PER_STAGE = 100; 
    let enemiesSpawnedInStage = 0;     
    let lastSpawnTime = 0;
    let lastSpawnedEnemyWidth = 30; // [íŒ¨ì¹˜ 1] ì´ì „ ëª¬ìŠ¤í„°ì˜ ë„ˆë¹„ ê¸°ì–µ
    
    let enemies = [];
    let particles = [];
    let slashes = []; 
    
    let lastAutoFireTime = 0;   
    let lastDevFireTime = 0;    
    
    let autoClickEnabled = false;
    let gameOver = false;
    let devAutoEnabled = false;

    // í”Œë ˆì´ì–´
    const PLAYER_WIDTH = 40;
    const PLAYER_HEIGHT = 30;
    let playerX = 0, playerY = 0;

    // ì—…ê·¸ë ˆì´ë“œ ìƒíƒœ
    let upgradeDamage = 1;
    let upgradeCount = 1;
    let upgradeAutoSpeed = 1;
    let upgradeCritChance = 1; // [íŒ¨ì¹˜ 2] ì¹˜ëª…íƒ€ í™•ë¥  ë ˆë²¨ (ê¸°ë³¸ 0%)
    let upgradeCritDamage = 1; // [íŒ¨ì¹˜ 2] ì¹˜ëª…íƒ€ í”¼í•´ ë ˆë²¨ (ê¸°ë³¸ 150%)
    
    // ============================================================
    // ë°¸ëŸ°ìŠ¤ ë° ë¹„ìš© ì„¤ì •
    // ============================================================
    
    const getCostDamage = (lv) => Math.floor(lv * 1.5); 
    const getCostCount = (lv) => 10 + Math.floor(Math.pow(lv, 1.8) * 5);
    const getCostAutoSpeed = (lv) => 10 + Math.floor(Math.pow(lv, 2.0));
    
    // [íŒ¨ì¹˜ 2] ì¹˜ëª…íƒ€ ë¹„ìš©
    const getCostCritChance = (lv) => 20 + Math.floor(Math.pow(lv, 1.6) * 10);
    const getCostCritDamage = (lv) => 20 + Math.floor(Math.pow(lv, 1.6) * 10);

    // ì¹˜ëª…íƒ€ ëŠ¥ë ¥ì¹˜ ê³„ì‚°
    const getCritChance = () => Math.min(100, upgradeCritChance - 1); // Lv1=0%, Lv2=1%...
    const getCritMultiplier = () => 1.5 + (upgradeCritDamage - 1) * 0.1; // Lv1=1.5ë°°, Lv2=1.6ë°°...

    function getAutoFireInterval() {
        const startInterval = 1000;
        const targetEarly = 300;
        const earlyLevels = 8;

        if (upgradeAutoSpeed <= earlyLevels) {
            const step = (startInterval - targetEarly) / (earlyLevels - 1);
            return Math.floor(startInterval - step * (upgradeAutoSpeed - 1));
        }
        
        const minInterval = 10;
        const decay = 0.98; 
        return Math.floor(Math.max(minInterval, targetEarly * Math.pow(decay, upgradeAutoSpeed - earlyLevels)));
    }

    // ============================================================
    // ë¦¬ì‚¬ì´ì¦ˆ
    // ============================================================
    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      canvasWidth = canvas.width = container.clientWidth;
      canvasHeight = canvas.height = container.clientHeight;
      playerX = canvasWidth/2 - PLAYER_WIDTH/2;
      playerY = canvasHeight - PLAYER_HEIGHT - 60; 
    }
    window.addEventListener('resize', () => { resizeCanvas(); initStars(); });
    resizeCanvas();

    // ============================================================
    // ì (Enemy) í´ë˜ìŠ¤
    // ============================================================
    class Enemy {
      constructor(type, health) {
        this.width = type === 'boss' ? 100 : type === 'miniboss' ? 60 : 30;
        this.height = type === 'boss' ? 80 : type === 'miniboss' ? 50 : 30;
        
        this.x = 0;
        this.y = 60; 
        
        this.type = type;
        this.maxHealth = health;
        this.health = health;
        
        this.baseSpeed = 3.0 + (stage * 0.1); 
        if(this.baseSpeed > 15) this.baseSpeed = 15; 

        this.direction = 1; 
        this.dropAmount = 30; 
      }

      update(dt) {
        const speed = this.baseSpeed * gameSpeed * (dt / 16);
        this.x += speed * this.direction;

        if (this.direction === 1 && this.x + this.width >= canvasWidth) {
            this.x = canvasWidth - this.width;
            this.y += this.dropAmount;
            this.direction = -1;
        }
        else if (this.direction === -1 && this.x <= 0) {
            this.x = 0;
            this.y += this.dropAmount;
            this.direction = 1;
        }

        if (this.y + this.height >= playerY) {
            gameOver = true;
        }
      }

      draw() {
        let color = '#00ffcc'; 
        let glow = '#00ffcc';
        
        if (this.type === 'miniboss') { color = '#ffaa00'; glow='#ffaa00'; }
        if (this.type === 'boss') { color = '#ff0055'; glow='#ff0055'; }

        ctx.fillStyle = color;
        ctx.shadowColor = glow;
        ctx.shadowBlur = 10;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.shadowBlur = 0;
        
        // ëˆˆ
        ctx.fillStyle = '#000';
        if (this.direction === 1) { 
             ctx.fillRect(this.x + this.width*0.6, this.y + this.height*0.2, this.width*0.15, this.width*0.15);
        } else { 
             ctx.fillRect(this.x + this.width*0.2, this.y + this.height*0.2, this.width*0.15, this.width*0.15);
        }

        // ì²´ë ¥ë°”
        const hpPercent = this.health / this.maxHealth;
        ctx.fillStyle = '#111';
        ctx.fillRect(this.x, this.y - 6, this.width, 4);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(this.x, this.y - 6, this.width * hpPercent, 4);
      }

      takeDamage(dmg) {
        this.health -= dmg;
        if (this.health <= 0) {
          let reward = 1 + Math.floor(stage / 10);
          if (this.type === 'miniboss') reward *= 20; 
          if (this.type === 'boss') reward *= 100;    
          gold += reward;
          spawnParticles(this.x + this.width/2, this.y + this.height/2, this.type);
          return true; 
        }
        return false;
      }
    }

    // ============================================================
    // ìŠ¤í° ë¡œì§ (ê²¹ì¹¨ ì™„ë²½ í•´ê²°)
    // ============================================================
    function trySpawnEnemy(now) {
        if (enemiesSpawnedInStage >= MAX_ENEMIES_PER_STAGE) return;
        
        const currentSpeed = 3.0 + (stage * 0.1); 
        const gap = 15; // ëª¬ìŠ¤í„° ê°„ ê°„ê²©
        
        // [íŒ¨ì¹˜ 1] ì§ì „ì— ì†Œí™˜ëœ ëª¬ìŠ¤í„°ì˜ ë„ˆë¹„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ëŒ€ê¸° ì‹œê°„ ê³„ì‚°
        // ëš±ëš±í•œ ë†ˆ(ë³´ìŠ¤)ì´ ë‚˜ì™”ìœ¼ë©´ ê·¸ë§Œí¼ ë” ê¸°ë‹¤ë ¤ì•¼ ë’·ë†ˆì´ ì•ˆ ê²¹ì¹¨
        // safeInterval = (ì§ì „ëª¬ìŠ¤í„°ë„ˆë¹„ + ê°„ê²©) / ì†ë„
        let safeInterval = (lastSpawnedEnemyWidth + gap) / currentSpeed * 20; 
        
        // [ì¶”ê°€ ë¡œì§] ë§Œì•½ ì´ë²ˆì— ë‚˜ì˜¬ ë†ˆì´ ë³´ìŠ¤ë¼ë©´ ë¯¸ë¦¬ ê³µê°„ì„ ë” í™•ë³´í•´ì•¼ í•¨
        // (ë³´ìŠ¤ê°€ ì• ë†ˆ ì—‰ë©ì´ë¥¼ ì°Œë¥´ë©´ ì•ˆ ë˜ë‹ˆê¹Œ)
        // í•˜ì§€ë§Œ trySpawnì—ì„œëŠ” ì•„ì§ ì´ë²ˆ ë†ˆ íƒ€ì…ì„ ëª¨ë¦„ -> spawnOneEnemyì—ì„œ ì²˜ë¦¬?
        // ê°„ë‹¨íˆ: ë³´ìŠ¤ ë‚˜ì˜¤ëŠ” íƒ€ì´ë°(100ë²ˆì§¸, 10ë‹¨ìœ„) ì§ì „ì—ëŠ” í…€ì„ ì¢€ ë” ì£¼ì.
        const nextCount = enemiesSpawnedInStage + 1;
        if (nextCount % 10 === 0 || nextCount === MAX_ENEMIES_PER_STAGE) {
             safeInterval += 200; // ë³´ìŠ¤ ë‚˜ì˜¤ê¸° ì „ ëœ¸ ë“¤ì´ê¸°
        }

        safeInterval = Math.max(60, safeInterval); // ìµœì†Œ 60ms

        if (now - lastSpawnTime > (safeInterval / gameSpeed)) {
            spawnOneEnemy();
            lastSpawnTime = now;
        }
    }

    function spawnOneEnemy() {
        const baseHealth = 5 + Math.pow(stage, 2.2);
        
        let type = 'normal';
        let health = baseHealth;

        const currentCount = enemiesSpawnedInStage + 1;

        if (currentCount === MAX_ENEMIES_PER_STAGE) {
            if (stage % 100 === 0) {
                type = 'boss';
                health = baseHealth * 300; 
            } 
            else if (stage % 10 === 0) {
                type = 'miniboss';
                health = baseHealth * 50;
            }
        }

        const newEnemy = new Enemy(type, health);
        enemies.push(newEnemy);
        
        // [íŒ¨ì¹˜ 1] ì´ë²ˆì— ë‚˜ì˜¨ ë†ˆ ë„ˆë¹„ ì €ì¥ -> ë‹¤ìŒ ìŠ¤í° ê°„ê²© ê³„ì‚°ì— ì”€
        lastSpawnedEnemyWidth = newEnemy.width;
        
        enemiesSpawnedInStage++;
    }

    // ============================================================
    // ì´í™íŠ¸ ì‹œìŠ¤í…œ (ì¹˜ëª…íƒ€ ì¶”ê°€)
    // ============================================================
    class SlashEffect {
        constructor(x, y, isCrit) {
            this.x = x;
            this.y = y;
            this.life = 1.0;
            this.angle = Math.random() * Math.PI * 2;
            this.isCrit = isCrit;
            // ì¹˜ëª…íƒ€ë©´ ë” í¬ê³  ì˜¤ë˜ê°
            this.scale = isCrit ? 1.5 : 1.0; 
        }
        update() {
            this.life -= this.isCrit ? 0.1 : 0.15; // ì¹˜ëª…íƒ€ëŠ” ì”ìƒì´ ì¢€ ë” ë‚¨ìŒ
            return this.life <= 0;
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.scale(this.scale, this.scale);
            ctx.beginPath();
            ctx.arc(0, 0, 40, 0, Math.PI); 
            
            // [íŒ¨ì¹˜ 3] ì¹˜ëª…íƒ€ ìƒ‰ìƒ êµ¬ë¶„
            if (this.isCrit) {
                ctx.strokeStyle = `rgba(255, 50, 50, ${this.life})`; // ë¹¨ê°•
                ctx.lineWidth = 6;
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
            } else {
                ctx.strokeStyle = `rgba(200, 255, 255, ${this.life})`; // ì²­ë¡
                ctx.lineWidth = 4;
                ctx.shadowBlur = 0;
            }
            
            ctx.stroke();
            ctx.restore();
        }
    }

    function spawnParticles(x, y, type) {
      const color = type==='boss'?'#f05':(type==='miniboss'?'#fa0':'#0fc');
      for(let i=0; i<6; i++) {
        particles.push({
          x, y,
          vx: (Math.random()-0.5)*8,
          vy: (Math.random()-0.5)*8,
          life: 1.0, color
        });
      }
    }

    // ============================================================
    // ê³µê²© (ì¹˜ëª…íƒ€ ì ìš©)
    // ============================================================
    function fire() {
        if(enemies.length === 0) return;

        let target = null;
        let maxY = -9999;
        
        enemies.forEach(e => {
            if (e.y > maxY) {
                maxY = e.y;
                target = e;
            }
        });

        if (target) {
            // [íŒ¨ì¹˜ 2] ì¹˜ëª…íƒ€ ê³„ì‚°
            const critChance = getCritChance();
            const isCrit = (Math.random() * 100) < critChance;
            
            // ì´í™íŠ¸ ìƒì„±
            slashes.push(new SlashEffect(target.x + target.width/2, target.y + target.height/2, isCrit));

            // ë°ë¯¸ì§€ ê³„ì‚°
            let finalDamage = upgradeDamage;
            if (isCrit) {
                finalDamage *= getCritMultiplier();
            }

            for(let i=0; i<upgradeCount; i++) {
                if(target.health <= 0) break; 
                if(target.takeDamage(finalDamage)) {
                    const idx = enemies.indexOf(target);
                    if(idx > -1) enemies.splice(idx, 1);
                    if (enemies.length > 0) target = enemies[0]; 
                    else break;
                }
            }
        }
    }

    // ============================================================
    // ë©”ì¸ ë£¨í”„
    // ============================================================
    let lastTime = 0;
    function gameLoop(now) {
      if(gameOver) {
        document.getElementById('gameOverOverlay').classList.add('show');
        return;
      }

      const dt = Math.min(now - lastTime, 100);
      lastTime = now;

      trySpawnEnemy(now);

      if (enemiesSpawnedInStage >= MAX_ENEMIES_PER_STAGE && enemies.length === 0) {
          stage++;
          enemiesSpawnedInStage = 0; 
          gold += Math.floor(stage * (1 + stage/10)); 
      }

      if (autoClickEnabled) {
         let interval = getAutoFireInterval() / gameSpeed;
         if (now - lastAutoFireTime > interval) {
             fire();
             lastAutoFireTime = now;
         }
      }

      if (devAutoEnabled) {
         let devInterval = 10 / gameSpeed;
         if (now - lastDevFireTime > devInterval) {
             fire();
             lastDevFireTime = now;
         }
      }

      ctx.fillStyle = '#050508';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      drawStars();

      enemies.forEach(e => {
          e.update(dt);
          e.draw();
      });

      for(let i=particles.length-1; i>=0; i--) {
          let p = particles[i];
          p.x += p.vx; p.y += p.vy; p.life -= 0.05;
          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y, 4, 4);
          if(p.life <= 0) particles.splice(i,1);
      }
      ctx.globalAlpha = 1.0;

      for(let i=slashes.length-1; i>=0; i--) {
          slashes[i].draw();
          if(slashes[i].update()) slashes.splice(i, 1);
      }

      drawPlayer(now);
      updateUI();
      
      requestAnimationFrame(gameLoop);
    }

    function drawPlayer(now) {
        const cx = playerX + PLAYER_WIDTH/2;
        const cy = playerY + PLAYER_HEIGHT/2;
        
        ctx.fillStyle = '#00ffcc';
        ctx.shadowColor = '#00ffcc';
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.moveTo(cx, playerY); 
        ctx.lineTo(playerX + PLAYER_WIDTH, playerY + PLAYER_HEIGHT); 
        ctx.lineTo(cx, playerY + PLAYER_HEIGHT - 10); 
        ctx.lineTo(playerX, playerY + PLAYER_HEIGHT); 
        ctx.closePath();
        ctx.fill();
        
        ctx.shadowBlur = 0;
    }

    function updateUI() {
        document.getElementById('goldDisplay').textContent = `ğŸ’° ${Math.floor(gold)} G`;
        
        const remaining = enemies.length + (MAX_ENEMIES_PER_STAGE - enemiesSpawnedInStage);
        let stageText = `STAGE ${stage}`;
        
        if (stage % 100 === 0) stageText += " [BOSS]";
        else if (stage % 10 === 0) stageText += " [ELITE]";
        
        document.getElementById('stageDisplay').textContent = `${stageText} (ë‚¨ì€ ì : ${remaining})`;

        // ê¸°ì¡´ ìƒì  UI ì—…ë°ì´íŠ¸
        document.querySelector('#damageLevel').textContent = `Lv.${upgradeDamage} (+${upgradeDamage})`;
        document.querySelector('#buyDamage').textContent = `${getCostDamage(upgradeDamage)}G`;
        document.querySelector('#buyDamage').disabled = gold < getCostDamage(upgradeDamage);

        document.querySelector('#countLevel').textContent = `Lv.${upgradeCount}`;
        document.querySelector('#buyCount').textContent = `${getCostCount(upgradeCount)}G`;
        document.querySelector('#buyCount').disabled = gold < getCostCount(upgradeCount);

        const currentInterval = getAutoFireInterval();
        document.querySelector('#autoSpeedLevel').textContent = `Lv.${upgradeAutoSpeed} (${(currentInterval/1000).toFixed(2)}s)`;
        document.querySelector('#buyAutoSpeed').textContent = `${getCostAutoSpeed(upgradeAutoSpeed)}G`;
        document.querySelector('#buyAutoSpeed').disabled = gold < getCostAutoSpeed(upgradeAutoSpeed);

        // [íŒ¨ì¹˜ 2] ì¹˜ëª…íƒ€ UI ì—…ë°ì´íŠ¸
        const critChance = getCritChance();
        const critMult = getCritMultiplier();
        
        document.querySelector('#critChanceLevel').textContent = `Lv.${upgradeCritChance} (${critChance}%)`;
        document.querySelector('#buyCritChance').textContent = `${getCostCritChance(upgradeCritChance)}G`;
        document.querySelector('#buyCritChance').disabled = (gold < getCostCritChance(upgradeCritChance)) || (critChance >= 100);
        if (critChance >= 100) document.querySelector('#buyCritChance').textContent = "MAX";

        document.querySelector('#critDamageLevel').textContent = `Lv.${upgradeCritDamage} (${Math.floor(critMult*100)}%)`;
        document.querySelector('#buyCritDamage').textContent = `${getCostCritDamage(upgradeCritDamage)}G`;
        document.querySelector('#buyCritDamage').disabled = gold < getCostCritDamage(upgradeCritDamage);


        let target = null; 
        let maxY = -9999;
        enemies.forEach(e => { if(e.y > maxY) { maxY = e.y; target = e; } });

        const bar = document.getElementById('healthBarFill');
        const label = document.getElementById('currentMonsterLabel');
        
        if (target) {
            const pct = (target.health / target.maxHealth) * 100;
            bar.style.width = `${Math.max(0, pct)}%`;
            let name = target.type === 'boss' ? 'BOSS' : target.type === 'miniboss' ? 'ELITE' : 'ENEMY';
            label.textContent = `${name} HP: ${Math.floor(target.health)}`;
        } else {
            bar.style.width = '0%';
            label.textContent = remaining > 0 ? 'ëŒ€ê¸° ì¤‘...' : 'WAVE CLEAR!';
        }
    }

    const stars = [];
    function initStars() {
        stars.length = 0;
        for(let i=0; i<60; i++) stars.push({x:Math.random()*canvasWidth, y:Math.random()*canvasHeight, s:Math.random()*2});
    }
    function drawStars() {
        ctx.fillStyle = '#fff';
        stars.forEach(s => { ctx.fillRect(s.x, s.y, s.s, s.s); });
    }

    canvas.addEventListener('click', fire); 

    const modal = document.getElementById('shopModal');
    document.getElementById('shopBtn').onclick = () => modal.classList.add('open');
    document.getElementById('shopClose').onclick = () => modal.classList.remove('open');
    
    // ê°œë°œì ë²„íŠ¼
    const devBtn = document.getElementById('devAutoBtn');
    devBtn.onclick = () => {
        devAutoEnabled = !devAutoEnabled;
        devBtn.classList.toggle('active', devAutoEnabled);
        if(devAutoEnabled) {
            devBtn.textContent = "ğŸ› ï¸ DEV: ON";
            lastDevFireTime = performance.now(); 
        } else {
            devBtn.textContent = "ğŸ› ï¸ DEV: OFF";
        }
    };

    // ê¾¹ ëˆ„ë¥´ê¸° ê¸°ëŠ¥
    function addHoldButton(btnId, action) {
      const btn = document.getElementById(btnId);
      let timer = null;

      const performAction = () => { action(); };
      const start = (e) => {
        if(timer) return;
        performAction();
        timer = setTimeout(() => {
             timer = setInterval(performAction, 80);
        }, 300);
      };
      const stop = () => {
        if(timer) { clearTimeout(timer); clearInterval(timer); timer = null; }
      };

      btn.addEventListener('mousedown', start);
      btn.addEventListener('mouseup', stop);
      btn.addEventListener('mouseleave', stop);
      btn.addEventListener('touchstart', (e) => { e.preventDefault(); start(); }); 
      btn.addEventListener('touchend', stop);
      btn.addEventListener('touchcancel', stop);
    }

    addHoldButton('buyDamage', () => {
        const cost = getCostDamage(upgradeDamage);
        if(gold >= cost) { gold -= cost; upgradeDamage++; updateUI(); }
    });
    addHoldButton('buyCount', () => {
        const cost = getCostCount(upgradeCount);
        if(gold >= cost) { gold -= cost; upgradeCount++; updateUI(); }
    });
    addHoldButton('buyAutoSpeed', () => {
        const cost = getCostAutoSpeed(upgradeAutoSpeed);
        if(gold >= cost) { gold -= cost; upgradeAutoSpeed++; updateUI(); }
    });
    // [íŒ¨ì¹˜ 2] ì¹˜ëª…íƒ€ ìƒì  ì—°ë™
    addHoldButton('buyCritChance', () => {
        const cost = getCostCritChance(upgradeCritChance);
        if(gold >= cost && getCritChance() < 100) { gold -= cost; upgradeCritChance++; updateUI(); }
    });
    addHoldButton('buyCritDamage', () => {
        const cost = getCostCritDamage(upgradeCritDamage);
        if(gold >= cost) { gold -= cost; upgradeCritDamage++; updateUI(); }
    });

    const autoBtn = document.getElementById('autoClickBtn');
    autoBtn.onclick = () => {
        autoClickEnabled = !autoClickEnabled;
        autoBtn.classList.toggle('on', autoClickEnabled);
        autoBtn.textContent = autoClickEnabled ? "âš¡ AUTO: ON" : "âš¡ AUTO: OFF";
    };

    document.querySelectorAll('.speedBtn').forEach(btn => {
        btn.onclick = () => {
            gameSpeed = parseInt(btn.dataset.speed);
            document.querySelectorAll('.speedBtn').forEach(b=>b.classList.remove('active'));
            btn.classList.add('active');
        }
    });

    document.getElementById('restartBtn').onclick = () => {
        gameOver = false;
        gold = 0; stage = 1; 
        enemies = []; enemiesSpawnedInStage = 0;
        upgradeDamage=1; upgradeCount=1; upgradeAutoSpeed=1;
        upgradeCritChance=1; upgradeCritDamage=1; // ì´ˆê¸°í™”
        
        document.getElementById('gameOverOverlay').classList.remove('show');
        initStars();
        requestAnimationFrame(gameLoop);
    };

    initStars();
    requestAnimationFrame(gameLoop);

  </script>
</body>
</html>